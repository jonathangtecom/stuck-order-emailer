{% extends "ui/layout.html" %}

{% block title %}Dry Run — Stuck Order Emailer{% endblock %}

{% block content %}
<!-- Active scheduled runs banner -->
<div id="active-runs-section" style="display: none; margin-bottom: 1rem;">
  <div class="flash-info" role="status">
    <span id="active-run-info"></span>
  </div>
</div>

<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
  <h2 style="margin-bottom: 0;">Dry Run</h2>
  <div style="display: flex; gap: 0.5rem; align-items: center;">
    <select id="store-select" style="margin-bottom: 0;">
      <option value="">All Stores</option>
      {% for store in stores %}
      <option value="{{ store.id }}">{{ store.name }}</option>
      {% endfor %}
    </select>
    <button id="btn-dry-run" onclick="runDryRun()">Run Dry Run</button>
  </div>
</div>

<p id="dry-run-description">
  Simulates the full email pipeline without sending any emails.
  Shows exactly which customers would receive an email.
</p>

<!-- Progress state -->
<div id="progress-state" style="display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
    <p id="progress-message" style="margin-bottom: 0;" aria-busy="true">Starting dry run...</p>
    <button id="btn-cancel" class="secondary outline" style="margin-bottom: 0;" onclick="cancelRun()">Cancel</button>
  </div>
  <progress id="progress-bar" value="0" max="100" style="margin-bottom: 0.25rem;"></progress>
  <small id="progress-detail" style="color: var(--pico-muted-color);"></small>
</div>

<!-- Error state -->
<div id="error-state" style="display: none;">
  <div class="flash-error" role="alert">
    <strong>Dry run failed:</strong> <span id="error-message"></span>
  </div>
  <button class="secondary outline" onclick="runDryRun()">Try Again</button>
</div>

<!-- Results -->
<div id="results-section" style="display: none;">
  <div class="dry-run-header">
    <small id="results-timestamp" style="color: var(--pico-muted-color);"></small>
  </div>

  <div class="stats-grid" id="summary-stats"></div>

  <div id="store-sections"></div>

  <div id="empty-state" style="display: none; text-align: center; padding: 2rem 0;">
    <h3>All clear</h3>
    <p>No emails would be sent right now. All orders are either already emailed, too recent, or tracking normally.</p>
  </div>
</div>

<!-- Email Preview Modal -->
<dialog id="email-preview-modal">
  <article style="max-width: 800px; width: 90vw;">
    <header>
      <button aria-label="Close" rel="prev" onclick="closePreviewModal()"></button>
      <h3 id="preview-modal-title">Email Preview</h3>
    </header>
    <div style="margin-bottom: 0.75rem;">
      <p id="preview-meta" style="margin-bottom: 0; font-size: 0.9rem; color: var(--pico-muted-color);"></p>
    </div>
    <iframe
      id="preview-iframe"
      class="preview-frame"
      sandbox="allow-same-origin"
      title="Email preview"
      style="margin-top: 0; width: 100%; height: 450px; border: 1px solid var(--pico-muted-border-color, #dee2e6); border-radius: 4px; background: #fff;">
    </iframe>
    <footer>
      <button class="secondary" onclick="closePreviewModal()">Close</button>
    </footer>
  </article>
</dialog>
{% endblock %}

{% block scripts %}
<script>
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
const emailBodies = {};
let currentRunId = null;
let pollInterval = null;
let activeRunsInterval = null;

async function runDryRun() {
  const btn = document.getElementById('btn-dry-run');
  const desc = document.getElementById('dry-run-description');
  const progress = document.getElementById('progress-state');
  const errorState = document.getElementById('error-state');
  const results = document.getElementById('results-section');

  const storeSelect = document.getElementById('store-select');
  const storeId = storeSelect.value;

  btn.disabled = true;
  btn.setAttribute('aria-busy', 'true');
  btn.textContent = 'Running...';
  desc.style.display = 'none';
  errorState.style.display = 'none';
  results.style.display = 'none';

  const storeName = storeId ? storeSelect.selectedOptions[0].text : 'all enabled stores';
  document.getElementById('progress-message').textContent = 'Starting dry run for ' + storeName + '...';
  document.getElementById('progress-bar').value = 0;
  document.getElementById('progress-bar').removeAttribute('value');
  document.getElementById('progress-detail').textContent = '';
  document.getElementById('btn-cancel').disabled = false;
  progress.style.display = 'block';

  try {
    let url = '/api/run?dry_run=1';
    if (storeId) url += '&store_id=' + encodeURIComponent(storeId);
    const resp = await fetch(url, {method: 'POST', headers: {'X-CSRF-Token': csrfToken}});
    const data = await resp.json();

    if (!resp.ok) {
      throw new Error(data.error || 'Unknown error');
    }

    currentRunId = data.run_id;
    pollInterval = setInterval(pollProgress, 2000);
    // Do an immediate first poll
    pollProgress();
  } catch (e) {
    progress.style.display = 'none';
    document.getElementById('error-message').textContent = e.message;
    errorState.style.display = 'block';
    resetButton();
  }
}

async function pollProgress() {
  if (!currentRunId) return;
  try {
    const resp = await fetch('/api/runs/' + currentRunId);
    if (!resp.ok) return;
    const data = await resp.json();

    updateProgressDisplay(data.progress, data.status);

    if (data.status === 'completed' || data.status === 'cancelled' || data.status === 'error') {
      clearInterval(pollInterval);
      pollInterval = null;
      document.getElementById('progress-state').style.display = 'none';
      resetButton();

      if (data.status === 'error') {
        document.getElementById('error-message').textContent = data.error || 'Unknown error';
        document.getElementById('error-state').style.display = 'block';
      } else {
        if (data.result) {
          renderResults(data.result, data.status === 'cancelled');
        }
      }
      currentRunId = null;
    }
  } catch (e) {
    // Network error — keep polling, it might recover
  }
}

function updateProgressDisplay(progress, status) {
  const msg = document.getElementById('progress-message');
  const bar = document.getElementById('progress-bar');
  const detail = document.getElementById('progress-detail');

  if (status === 'running' && progress.current_store) {
    msg.textContent = 'Processing ' + progress.current_store + '...';
  }

  if (progress.total_orders > 0) {
    const pct = Math.round((progress.orders_checked / progress.total_orders) * 100);
    bar.value = pct;
    bar.max = 100;
    detail.textContent = progress.orders_checked + ' / ' + progress.total_orders + ' orders checked'
      + ' — ' + progress.emails_found + ' would send'
      + ', ' + progress.skipped + ' skipped';
  } else if (progress.orders_checked > 0) {
    bar.removeAttribute('value');
    detail.textContent = progress.orders_checked + ' orders checked'
      + ' — ' + progress.emails_found + ' would send';
  }

  if (progress.total_stores > 1 && progress.stores_processed > 0) {
    detail.textContent += ' (store ' + progress.stores_processed + '/' + progress.total_stores + ')';
  }
}

async function cancelRun() {
  if (!currentRunId) return;
  document.getElementById('btn-cancel').disabled = true;
  document.getElementById('progress-message').textContent = 'Cancelling...';
  try {
    await fetch('/api/runs/' + currentRunId + '/cancel',
      {method: 'POST', headers: {'X-CSRF-Token': csrfToken}});
  } catch (e) {
    // Ignore — poll will pick up the status change
  }
}

function resetButton() {
  const btn = document.getElementById('btn-dry-run');
  btn.disabled = false;
  btn.removeAttribute('aria-busy');
  btn.textContent = 'Run Dry Run';
}

function renderResults(data, wasCancelled) {
  const results = document.getElementById('results-section');
  const emptyState = document.getElementById('empty-state');
  const storeSections = document.getElementById('store-sections');

  const now = new Date();
  let timestamp = 'Report generated ' + now.toLocaleDateString() + ' at ' + now.toLocaleTimeString();
  if (wasCancelled) timestamp += ' (cancelled — partial results)';
  document.getElementById('results-timestamp').textContent = timestamp;

  document.getElementById('summary-stats').innerHTML =
    '<div class="stat-card"><p class="stat-value">' + data.processed + '</p><p class="stat-label">Stores Processed</p></div>' +
    '<div class="stat-card"><p class="stat-value">' + data.emails_sent + '</p><p class="stat-label">Emails Would Send</p></div>' +
    '<div class="stat-card"><p class="stat-value">' + data.skipped + '</p><p class="stat-label">Skipped</p></div>' +
    '<div class="stat-card"><p class="stat-value">' + data.errors + '</p><p class="stat-label">Errors</p></div>';

  storeSections.innerHTML = '';
  Object.keys(emailBodies).forEach(k => delete emailBodies[k]);

  if (data.emails_sent === 0 && data.errors === 0) {
    emptyState.style.display = 'block';
    storeSections.style.display = 'none';
  } else {
    emptyState.style.display = 'none';
    storeSections.style.display = 'block';
    renderStoreSections(data.details);
  }

  results.style.display = 'block';
}

function renderStoreSections(details) {
  const container = document.getElementById('store-sections');

  for (let si = 0; si < details.length; si++) {
    const detail = details[si];
    const section = document.createElement('details');
    section.classList.add('store-accordion');
    if (si === 0) section.setAttribute('open', '');

    const summary = document.createElement('summary');

    const nameSpan = document.createElement('span');
    nameSpan.classList.add('store-accordion-name');
    nameSpan.textContent = detail.store;
    summary.appendChild(nameSpan);

    const badge = document.createElement('span');
    if (detail.error) {
      badge.classList.add('badge', 'badge-error');
      badge.textContent = 'ERROR';
    } else {
      const count = detail.would_send ? detail.would_send.length : 0;
      if (count === 0) {
        badge.classList.add('badge', 'badge-clear');
        badge.textContent = '0 emails';
      } else {
        badge.classList.add('badge', 'badge-send');
        badge.textContent = count + ' email' + (count !== 1 ? 's' : '');
      }
    }
    summary.appendChild(badge);
    section.appendChild(summary);

    const content = document.createElement('div');
    content.classList.add('store-accordion-content');

    if (detail.error) {
      const errorP = document.createElement('p');
      errorP.classList.add('store-error-message');
      errorP.textContent = detail.error;
      content.appendChild(errorP);
    } else if (!detail.would_send || detail.would_send.length === 0) {
      const emptyP = document.createElement('p');
      emptyP.style.color = 'var(--pico-muted-color)';
      emptyP.textContent = 'No emails to send for this store. All orders are up to date.';
      content.appendChild(emptyP);
    } else {
      if (detail.skipped > 0) {
        const skippedP = document.createElement('p');
        skippedP.style.fontSize = '0.9rem';
        skippedP.style.color = 'var(--pico-muted-color)';
        skippedP.textContent = detail.skipped + ' order' + (detail.skipped !== 1 ? 's' : '') + ' skipped (already emailed)';
        content.appendChild(skippedP);
      }

      const table = document.createElement('table');
      table.classList.add('compact');
      table.setAttribute('role', 'grid');

      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>Order</th><th>Customer</th><th>Days Waiting</th><th>Status</th><th></th></tr>';
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      for (let oi = 0; oi < detail.would_send.length; oi++) {
        const email = detail.would_send[oi];
        const key = si + '-' + oi;
        emailBodies[key] = {
          subject: email.subject,
          customerEmail: email.customer_email,
          customerName: email.customer_name,
          trackingNumber: email.tracking_number,
          orderNumber: email.order_number,
          renderedBody: email.rendered_body,
        };

        const tr = document.createElement('tr');

        const tdOrder = document.createElement('td');
        const orderStrong = document.createElement('strong');
        orderStrong.textContent = email.order_number;
        tdOrder.appendChild(orderStrong);
        tr.appendChild(tdOrder);

        const tdCustomer = document.createElement('td');
        tdCustomer.textContent = email.customer_name;
        const emailSmall = document.createElement('small');
        emailSmall.style.display = 'block';
        emailSmall.style.color = 'var(--pico-muted-color)';
        emailSmall.textContent = email.customer_email;
        tdCustomer.appendChild(emailSmall);
        tr.appendChild(tdCustomer);

        const tdDays = document.createElement('td');
        tdDays.textContent = email.days_waiting + ' days';
        tr.appendChild(tdDays);

        const tdStatus = document.createElement('td');
        const statusCode = document.createElement('code');
        statusCode.textContent = email.tracking_status || 'UNFULFILLED';
        tdStatus.appendChild(statusCode);
        tr.appendChild(tdStatus);

        const tdPreview = document.createElement('td');
        const previewBtn = document.createElement('button');
        previewBtn.classList.add('secondary', 'outline');
        previewBtn.style.fontSize = '0.8rem';
        previewBtn.style.padding = '0.25rem 0.5rem';
        previewBtn.setAttribute('data-key', key);
        previewBtn.textContent = 'Preview';
        previewBtn.addEventListener('click', function() {
          openPreviewModal(this.getAttribute('data-key'));
        });
        tdPreview.appendChild(previewBtn);
        tr.appendChild(tdPreview);

        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      content.appendChild(table);
    }

    section.appendChild(content);
    container.appendChild(section);
  }
}

function openPreviewModal(key) {
  const data = emailBodies[key];
  if (!data) return;

  document.getElementById('preview-modal-title').textContent =
    'Email Preview: ' + data.orderNumber;
  document.getElementById('preview-meta').textContent =
    'To: ' + data.customerEmail + '  |  Subject: ' + data.subject;

  document.getElementById('preview-iframe').srcdoc = data.renderedBody || '';
  document.getElementById('email-preview-modal').showModal();
}

function closePreviewModal() {
  document.getElementById('email-preview-modal').close();
  document.getElementById('preview-iframe').srcdoc = '';
}

// ── Active scheduled runs polling ────────────────────────────

async function checkActiveRuns() {
  try {
    const resp = await fetch('/api/runs/active');
    if (!resp.ok) return;
    const runs = await resp.json();
    const scheduled = runs.filter(function(r) { return r.source === 'scheduler'; });
    const section = document.getElementById('active-runs-section');

    if (scheduled.length > 0) {
      const parts = scheduled.map(function(r) {
        let text = r.current_store + ': ';
        if (r.total_orders > 0) {
          text += r.orders_checked + '/' + r.total_orders + ' orders';
        } else {
          text += 'fetching orders...';
        }
        if (r.emails_found > 0) {
          text += ', ' + r.emails_found + ' sent';
        }
        return text;
      });
      document.getElementById('active-run-info').textContent =
        'Scheduled run in progress: ' + parts.join(' | ');
      section.style.display = 'block';
    } else {
      section.style.display = 'none';
    }
  } catch (e) {
    // Ignore network errors
  }
}

activeRunsInterval = setInterval(checkActiveRuns, 5000);
checkActiveRuns();
</script>
{% endblock %}
